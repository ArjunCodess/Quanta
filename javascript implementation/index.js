const fs = require('fs');

/**
 * Lexical analyzer for the Quantum programming language.
 * This function takes a string of Quantum code as input and returns an array of tokens.
 *
 * @param {string} input - The Quantum code to be tokenized.
 * @returns {Array} - An array of tokens, where each token is an object with a 'type' and 'value' property.
*/
function lexer(input) {
     const tokens = [];
     let cursor = 0;

     while (cursor < input.length) {
          let char = input[cursor];

          // Skip whitespace characters
          if (/\s/.test(char)) {
               cursor++;
               continue;
          }

          // Identify and tokenize keywords and identifiers
          if (/[a-zA-Z]/.test(char)) {
               let word = '';

               while (/[a-zA-Z0-9]/.test(char)) {
                    word += char;
                    cursor++;
                    if (cursor >= input.length) break;
                    char = input[cursor];
               }

               // Check if the word is a keyword
               if (word === 'let' || word === 'write') {
                    tokens.push({ type: 'keyword', value: word });
               } else {
                    tokens.push({ type: 'identifier', value: word });
               }

               continue;
          }

          // Identify and tokenize numbers
          if (/[0-9]/.test(char)) {
               let number = '';

               while (/[0-9]/.test(char)) {
                    number += char;
                    cursor++;
                    if (cursor >= input.length) break;
                    char = input[cursor];
               }

               tokens.push({ type: 'number', value: parseInt(number) });

               continue;
          }

          // Identify and tokenize operators
          if (/[\+\-\*\/=]/.test(char)) {
               tokens.push({ type: 'operator', value: char });
               cursor++;
               continue;
          }

          cursor++;
     }

     return tokens;
}

/**
 * Parses the given tokens into an Abstract Syntax Tree (AST).
 *
 * @param {Array} tokens - An array of tokens generated by the lexer.
 * @returns {Object} - The Abstract Syntax Tree (AST) representing the parsed code.
*/
function parser(tokens) {
     const ast = {
          type: 'Program',
          body: [],
     };

     while (tokens.length > 0) {
          let token = tokens.shift();

          // Handle variable declaration
          if (token.type === 'keyword' && token.value === 'let') {
               let declaration = {
                    type: 'Declaration',
                    name: tokens.shift().value,
                    value: null,
               };

               // Check for assignment operator
               if (tokens[0].type === 'operator' && tokens[0].value === '=') {
                    tokens.shift();

                    let expression = '';

                    // Collect expression until next keyword
                    while (tokens.length > 0 && tokens[0].type !== 'keyword') {
                         expression += tokens.shift().value;
                    }

                    // Trim trailing whitespace
                    declaration.value = expression.trim();
               }

               // Add declaration to AST
               ast.body.push(declaration);
          }

          // Handle print statement
          if (token.type === 'keyword' && token.value === 'write') {
               ast.body.push({
                    type: 'Print',
                    expression: tokens.shift().value,
               });
          }
     }

     return ast;
}

/**
 * Generates executable JavaScript code from the given Abstract Syntax Tree (AST) node.
 *
 * @param {Object} node - The AST node to generate code for.
 * @returns {string} - The generated JavaScript code.
*/
function codeGenerator(node) {
     /**
      * Switch statement to handle different types of AST nodes.
      */
     switch (node.type) {
          /**
           * Case for 'Program' node.
           * Recursively generates code for each child node and joins them with newlines.
           */
          case 'Program':
               return node.body.map(codeGenerator).join('\n');

          /**
           * Case for 'Declaration' node.
           * Generates JavaScript code for variable declaration.
           * @param {string} node.name - The name of the variable.
           * @param {string} node.value - The value of the variable.
           */
          case 'Declaration':
               return `let ${node.name} = ${node.value}`;

          /**
           * Case for 'Print' node.
           * Generates JavaScript code for console.log statement.
           * @param {string} node.expression - The expression to be printed.
           */
          case 'Print':
               return `console.log(${node.expression})`;
     }
}

/**
 * Executes the given JavaScript code.
 * This function is used to run the generated JavaScript code from the Quantum compiler.
 *
 * @param {string} input - The JavaScript code to be executed.
 * @returns {void} - This function does not return any value.
 *
 * @example
 * runner("console.log('Hello, Quantum!')");
*/
function runner(input) {
     eval(input);
}

/**
 * Compiles the given Quantum code into executable JavaScript code.
 *
 * @param {string} input - The Quantum code to be compiled.
 * @returns {string} - The executable JavaScript code.
 *
 * @example
 * const code = `
 *  let myVariable = 10
 *  write myVariable
 * `;
 *
 * const executable = compiler(code);
 * console.log(executable);
 * // Output:
 * // let myVariable = 10
 * // console.log(myVariable)
*/
function compiler(input) {
     const tokens = lexer(input);
     const ast = parser(tokens);
     const executableCode = codeGenerator(ast);

     return executableCode;
}

const path = process.cwd();
const buffer = fs.readFileSync(path + "/index.quanta");

const code = buffer.toString();

const executable = compiler(code);
runner(executable);